-- Expense DB Schema (SQLite)
-- SQL ONLY: tables, indexes, triggers, and views

PRAGMA foreign_keys = ON;

-- Optional: app metadata for migrations
CREATE TABLE IF NOT EXISTS app_meta (
  key   TEXT PRIMARY KEY,
  value TEXT
);
INSERT OR IGNORE INTO app_meta(key, value) VALUES ('db_version', '1');

-- 1) Users (keep for future sync/multi-user; safe to keep single row)
CREATE TABLE IF NOT EXISTS users (
  user_id    INTEGER PRIMARY KEY AUTOINCREMENT,
  uid        TEXT UNIQUE,                    -- UUID for sync
  name       TEXT,
  created_at TEXT DEFAULT (datetime('now'))
);

-- 2) Accounts (cash, bank, card, e-wallet)
CREATE TABLE IF NOT EXISTS accounts (
  account_id  INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id     INTEGER NOT NULL,
  name        TEXT NOT NULL,
  type        TEXT NOT NULL CHECK (type IN ('CASH','BANK','CARD','EWALLET','OTHER')),
  currency    TEXT NOT NULL,                 -- ISO 4217
  is_archived INTEGER NOT NULL DEFAULT 0,    -- 0=false,1=true
  created_at  TEXT DEFAULT (datetime('now')),
  updated_at  TEXT,
  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_accounts_user ON accounts(user_id);

-- 3) Categories (tree; type filters EXPENSE vs INCOME)
CREATE TABLE IF NOT EXISTS categories (
  category_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id     INTEGER NOT NULL,
  name        TEXT NOT NULL,
  type        TEXT NOT NULL CHECK (type IN ('EXPENSE','INCOME')),
  parent_id   INTEGER,                        -- NULL = root
  icon        TEXT,
  sort_order  INTEGER DEFAULT 0,
  FOREIGN KEY (user_id)   REFERENCES users(user_id) ON DELETE CASCADE,
  FOREIGN KEY (parent_id) REFERENCES categories(category_id) ON DELETE SET NULL,
  UNIQUE(user_id, name, type)
);
CREATE INDEX IF NOT EXISTS idx_categories_parent ON categories(parent_id);
CREATE INDEX IF NOT EXISTS idx_categories_user_type ON categories(user_id, type);

-- 4) Payees (merchants/people)
CREATE TABLE IF NOT EXISTS payees (
  payee_id   INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id    INTEGER NOT NULL,
  name       TEXT NOT NULL,
  normalized TEXT,                             -- for dedupe/search
  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
  UNIQUE(user_id, name)
);
CREATE INDEX IF NOT EXISTS idx_payees_user ON payees(user_id);

-- 5) Transactions (one row per event)
CREATE TABLE IF NOT EXISTS transactions (
  transaction_id    INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id           INTEGER NOT NULL,
  account_id        INTEGER NOT NULL,         -- account affected by this row
  type              TEXT NOT NULL CHECK (type IN ('EXPENSE','INCOME','TRANSFER')),
  amount            REAL NOT NULL,            -- signed: expense < 0, income > 0; for TRANSFER sign from account perspective
  currency          TEXT NOT NULL,
  category_id       INTEGER,                  -- NULL for TRANSFER or uncategorized
  payee_id          INTEGER,
  note              TEXT,
  occurred_on       TEXT NOT NULL,            -- date only YYYY-MM-DD
  occurred_at       TEXT,                     -- optional timestamp
  transfer_group_id TEXT,                     -- UUID to link both legs of a transfer
  has_split         INTEGER NOT NULL DEFAULT 0, -- 0=no splits, 1=has splits (maintained by triggers)
  created_at        TEXT DEFAULT (datetime('now')),
  updated_at        TEXT,
  FOREIGN KEY (user_id)     REFERENCES users(user_id) ON DELETE CASCADE,
  FOREIGN KEY (account_id)  REFERENCES accounts(account_id) ON DELETE CASCADE,
  FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE SET NULL,
  FOREIGN KEY (payee_id)    REFERENCES payees(payee_id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_tx_user_date ON transactions(user_id, occurred_on);
CREATE INDEX IF NOT EXISTS idx_tx_account_date ON transactions(account_id, occurred_on);
CREATE INDEX IF NOT EXISTS idx_tx_transfer_group ON transactions(transfer_group_id);
CREATE INDEX IF NOT EXISTS idx_tx_category ON transactions(category_id);
CREATE INDEX IF NOT EXISTS idx_tx_type ON transactions(type);
CREATE INDEX IF NOT EXISTS idx_tx_has_split ON transactions(has_split);

-- 6) Optional per-line splits (subcategories/allocations)
CREATE TABLE IF NOT EXISTS transaction_splits (
  split_id       INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_id INTEGER NOT NULL,
  category_id    INTEGER NOT NULL,
  amount         REAL NOT NULL,               -- usually same sign as parent
  note           TEXT,
  FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE,
  FOREIGN KEY (category_id)    REFERENCES categories(category_id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_splits_tx ON transaction_splits(transaction_id);

-- 7) Tags & link table (many-to-many)
CREATE TABLE IF NOT EXISTS tags (
  tag_id   INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id  INTEGER NOT NULL,
  name     TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
  UNIQUE(user_id, name)
);
CREATE TABLE IF NOT EXISTS transaction_tags (
  transaction_id INTEGER NOT NULL,
  tag_id         INTEGER NOT NULL,
  PRIMARY KEY (transaction_id, tag_id),
  FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id)         REFERENCES tags(tag_id) ON DELETE CASCADE
);

-- 8) Budgets & rules (add when needed)
CREATE TABLE IF NOT EXISTS budgets (
  budget_id   INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id     INTEGER NOT NULL,
  name        TEXT NOT NULL,
  currency    TEXT NOT NULL,
  period_type TEXT NOT NULL CHECK (period_type IN ('MONTH','WEEK','YEAR','CUSTOM')),
  start_on    TEXT NOT NULL,                  -- anchor date
  amount      REAL NOT NULL,                  -- limit
  include_transfers INTEGER NOT NULL DEFAULT 0,
  created_at  TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS budget_rules (
  rule_id     INTEGER PRIMARY KEY AUTOINCREMENT,
  budget_id   INTEGER NOT NULL,
  include     INTEGER NOT NULL DEFAULT 1,     -- 1 include, 0 exclude
  category_id INTEGER,                        -- NULL = any
  account_id  INTEGER,                        -- NULL = any
  tag_id      INTEGER,                        -- NULL = any
  FOREIGN KEY (budget_id)  REFERENCES budgets(budget_id) ON DELETE CASCADE,
  FOREIGN KEY (category_id)REFERENCES categories(category_id) ON DELETE CASCADE,
  FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id)     REFERENCES tags(tag_id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_budget_rules_budget ON budget_rules(budget_id);

-- 9) Recurring rules (template + schedule)
CREATE TABLE IF NOT EXISTS recurring_rules (
  rule_id       INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id       INTEGER NOT NULL,
  template_json TEXT NOT NULL,                -- serialized draft of a transaction
  freq          TEXT NOT NULL CHECK (freq IN ('DAILY','WEEKLY','MONTHLY','YEARLY','CUSTOM')),
  interval      INTEGER NOT NULL DEFAULT 1,
  byweekday     TEXT,                         -- e.g. 'MO,WE,FR'
  bymonthday    TEXT,                         -- e.g. '1,15'
  next_run_on   TEXT NOT NULL,
  is_paused     INTEGER NOT NULL DEFAULT 0,
  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_recurring_user ON recurring_rules(user_id);

-- 10) Attachments (file metadata only)
CREATE TABLE IF NOT EXISTS attachments (
  attachment_id  INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_id INTEGER NOT NULL,
  uri            TEXT NOT NULL,               -- local path or remote URL
  mime_type      TEXT,
  note           TEXT,
  FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_attachments_tx ON attachments(transaction_id);

-- 11) Exchange rates (for reporting in base currency)
CREATE TABLE IF NOT EXISTS exchange_rates (
  rate_date TEXT NOT NULL,                    -- YYYY-MM-DD
  base      TEXT NOT NULL,                    -- e.g., 'SGD'
  quote     TEXT NOT NULL,                    -- e.g., 'USD'
  rate      REAL NOT NULL,                    -- base_per_quote: base = rate * quote
  PRIMARY KEY (rate_date, base, quote)
);

/* ===================== TRIGGERS ===================== */
-- Enforce sign convention: EXPENSE must be negative
CREATE TRIGGER IF NOT EXISTS trg_tx_sign_expense BEFORE INSERT ON transactions
FOR EACH ROW
WHEN NEW.type = 'EXPENSE' AND NEW.amount > 0
BEGIN
  SELECT RAISE(ABORT, 'Expense must be negative');
END;

-- Enforce sign convention: INCOME must be positive
CREATE TRIGGER IF NOT EXISTS trg_tx_sign_income BEFORE INSERT ON transactions
FOR EACH ROW
WHEN NEW.type = 'INCOME' AND NEW.amount < 0
BEGIN
  SELECT RAISE(ABORT, 'Income must be positive');
END;

-- Prevent category on TRANSFER
CREATE TRIGGER IF NOT EXISTS trg_tx_transfer_no_cat BEFORE INSERT ON transactions
FOR EACH ROW
WHEN NEW.type = 'TRANSFER' AND NEW.category_id IS NOT NULL
BEGIN
  SELECT RAISE(ABORT, 'Transfers cannot have category');
END;

-- Maintain has_split flag: set to 1 on first split insert
CREATE TRIGGER IF NOT EXISTS trg_split_flag_ins
AFTER INSERT ON transaction_splits
BEGIN
  UPDATE transactions
  SET has_split = 1
  WHERE transaction_id = NEW.transaction_id;
END;

-- Maintain has_split flag: recompute on update
CREATE TRIGGER IF NOT EXISTS trg_split_flag_upd
AFTER UPDATE ON transaction_splits
BEGIN
  UPDATE transactions
  SET has_split = CASE
    WHEN EXISTS (SELECT 1 FROM transaction_splits s WHERE s.transaction_id = NEW.transaction_id)
      THEN 1 ELSE 0 END
  WHERE transaction_id = NEW.transaction_id;
END;

-- Maintain has_split flag: clear when last split deleted
CREATE TRIGGER IF NOT EXISTS trg_split_flag_del
AFTER DELETE ON transaction_splits
BEGIN
  UPDATE transactions
  SET has_split = CASE
    WHEN EXISTS (SELECT 1 FROM transaction_splits s WHERE s.transaction_id = OLD.transaction_id)
      THEN 1 ELSE 0 END
  WHERE transaction_id = OLD.transaction_id;
END;

/* ======================= VIEWS ====================== */
-- Running balance per account (native currency)
CREATE VIEW IF NOT EXISTS v_account_running_balance AS
SELECT 
  account_id,
  transaction_id,
  occurred_on,
  SUM(amount) OVER (
    PARTITION BY account_id
    ORDER BY occurred_on, transaction_id
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS running_balance
FROM transactions;

-- Daily totals by type (exclude transfers as they are internal moves)
CREATE VIEW IF NOT EXISTS v_daily_type_totals AS
SELECT occurred_on, type,
       SUM(amount) AS total
FROM transactions
WHERE type IN ('EXPENSE','INCOME')
GROUP BY occurred_on, type;

/* =================== QUERY SNIPPETS ================= */
-- This month spend by category (negative totals)
-- Replace ? with current user_id
-- SELECT c.name, ROUND(SUM(t.amount),2) AS total
-- FROM transactions t
-- JOIN categories c ON c.category_id = t.category_id
-- WHERE t.user_id = ?
--   AND t.type = 'EXPENSE'
--   AND t.occurred_on BETWEEN date('now','start of month') AND date('now')
-- GROUP BY c.name
-- ORDER BY total ASC;

-- Account balance today (native currency)
-- SELECT a.name, ROUND(COALESCE(SUM(t.amount),0),2) AS balance
-- FROM accounts a
-- LEFT JOIN transactions t ON t.account_id = a.account_id
-- WHERE a.user_id = ?
-- GROUP BY a.account_id
-- ORDER BY a.name;

/* ===================== TRANSFERS ==================== */
-- Example pseudo-steps for a transfer of 100 SGD from A to B
-- BEGIN TRANSACTION;
-- INSERT INTO transactions(user_id, account_id, type, amount, currency, occurred_on, transfer_group_id)
-- VALUES (:user, :src_account, 'TRANSFER', -100, 'SGD', date('now'), :uuid);
-- INSERT INTO transactions(user_id, account_id, type, amount, currency, occurred_on, transfer_group_id)
-- VALUES (:user, :dst_account, 'TRANSFER', +100, 'SGD', date('now'), :uuid);
-- COMMIT;
